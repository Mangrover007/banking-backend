// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: accounts.sql

package repository

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createCheckingAccount = `-- name: CreateCheckingAccount :one
INSERT INTO checking_accounts (account_id, overdraft_limit, maintenance_fee)
VALUES (
    $1,
    $2,
    $3
)
RETURNING account_id, overdraft_limit, maintenance_fee
`

type CreateCheckingAccountParams struct {
	AccountID      uuid.UUID
	OverdraftLimit int64
	MaintenanceFee int64
}

func (q *Queries) CreateCheckingAccount(ctx context.Context, arg CreateCheckingAccountParams) (CheckingAccount, error) {
	row := q.db.QueryRow(ctx, createCheckingAccount, arg.AccountID, arg.OverdraftLimit, arg.MaintenanceFee)
	var i CheckingAccount
	err := row.Scan(&i.AccountID, &i.OverdraftLimit, &i.MaintenanceFee)
	return i, err
}

const createSavingsAccount = `-- name: CreateSavingsAccount :one
INSERT INTO savings_accounts (account_id, interest_rate, min_balance, withdrawal_limit)
VALUES (
    $1,
    $2,
    $3,
    $4
)
RETURNING account_id, interest_rate, min_balance, withdrawal_limit
`

type CreateSavingsAccountParams struct {
	AccountID       uuid.UUID
	InterestRate    pgtype.Numeric
	MinBalance      int64
	WithdrawalLimit int64
}

func (q *Queries) CreateSavingsAccount(ctx context.Context, arg CreateSavingsAccountParams) (SavingsAccount, error) {
	row := q.db.QueryRow(ctx, createSavingsAccount,
		arg.AccountID,
		arg.InterestRate,
		arg.MinBalance,
		arg.WithdrawalLimit,
	)
	var i SavingsAccount
	err := row.Scan(
		&i.AccountID,
		&i.InterestRate,
		&i.MinBalance,
		&i.WithdrawalLimit,
	)
	return i, err
}

const findAccount = `-- name: FindAccount :one
SELECT id, account_number, balance, type, fk_user_id, created_at, updated_at FROM accounts
WHERE
    fk_user_id = $1 AND
    type = $2
`

type FindAccountParams struct {
	FkUserID uuid.UUID
	Type     AccountType
}

func (q *Queries) FindAccount(ctx context.Context, arg FindAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, findAccount, arg.FkUserID, arg.Type)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.AccountNumber,
		&i.Balance,
		&i.Type,
		&i.FkUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const lockTransferAccount = `-- name: LockTransferAccount :execrows
SELECT id, account_number, balance, type, fk_user_id, created_at, updated_at FROM accounts
WHERE id = $1
FOR UPDATE
`

func (q *Queries) LockTransferAccount(ctx context.Context, id uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, lockTransferAccount, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const openAccount = `-- name: OpenAccount :one
INSERT INTO accounts (account_number, balance, type, fk_user_id)
VALUES (
    $1,
    $2,
    $3,
    $4
)
RETURNING id, account_number, balance, type, fk_user_id, created_at, updated_at
`

type OpenAccountParams struct {
	AccountNumber string
	Balance       int64
	Type          AccountType
	FkUserID      uuid.UUID
}

func (q *Queries) OpenAccount(ctx context.Context, arg OpenAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, openAccount,
		arg.AccountNumber,
		arg.Balance,
		arg.Type,
		arg.FkUserID,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.AccountNumber,
		&i.Balance,
		&i.Type,
		&i.FkUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateBalanceDeposit = `-- name: UpdateBalanceDeposit :execrows
UPDATE accounts
SET
    balance = balance + $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateBalanceDepositParams struct {
	ID      uuid.UUID
	Balance int64
}

func (q *Queries) UpdateBalanceDeposit(ctx context.Context, arg UpdateBalanceDepositParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateBalanceDeposit, arg.ID, arg.Balance)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateBalanceWithdraw = `-- name: UpdateBalanceWithdraw :execrows
UPDATE accounts
SET
    balance = balance - $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND balance >= $2
`

type UpdateBalanceWithdrawParams struct {
	ID      uuid.UUID
	Balance int64
}

func (q *Queries) UpdateBalanceWithdraw(ctx context.Context, arg UpdateBalanceWithdrawParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateBalanceWithdraw, arg.ID, arg.Balance)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
