// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: accounts.sql

package repository

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const findAccount = `-- name: FindAccount :one
SELECT balance, type, fk_user_id, created_at, updated_at, account_number FROM accounts
WHERE
    fk_user_id = $1 AND
    type = $2
`

type FindAccountParams struct {
	FkUserID uuid.UUID
	Type     AccountType
}

func (q *Queries) FindAccount(ctx context.Context, arg FindAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, findAccount, arg.FkUserID, arg.Type)
	var i Account
	err := row.Scan(
		&i.Balance,
		&i.Type,
		&i.FkUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccountNumber,
	)
	return i, err
}

const findAccountByID = `-- name: FindAccountByID :one
SELECT balance, type, fk_user_id, created_at, updated_at, account_number FROM accounts
WHERE account_number = $1
`

func (q *Queries) FindAccountByID(ctx context.Context, accountNumber uuid.UUID) (Account, error) {
	row := q.db.QueryRow(ctx, findAccountByID, accountNumber)
	var i Account
	err := row.Scan(
		&i.Balance,
		&i.Type,
		&i.FkUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccountNumber,
	)
	return i, err
}

const findAllAccountsByID = `-- name: FindAllAccountsByID :many
SELECT account_number, balance, type FROM
accounts INNER JOIN users
ON accounts.fk_user_id = users.id
WHERE id = $1
`

type FindAllAccountsByIDRow struct {
	AccountNumber uuid.UUID
	Balance       int64
	Type          AccountType
}

func (q *Queries) FindAllAccountsByID(ctx context.Context, id uuid.UUID) ([]FindAllAccountsByIDRow, error) {
	rows, err := q.db.Query(ctx, findAllAccountsByID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindAllAccountsByIDRow
	for rows.Next() {
		var i FindAllAccountsByIDRow
		if err := rows.Scan(&i.AccountNumber, &i.Balance, &i.Type); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lockTransferAccount = `-- name: LockTransferAccount :execrows
SELECT balance, type, fk_user_id, created_at, updated_at, account_number FROM accounts
WHERE account_number = $1
FOR UPDATE
`

func (q *Queries) LockTransferAccount(ctx context.Context, accountNumber uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, lockTransferAccount, accountNumber)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const openAccount = `-- name: OpenAccount :one
INSERT INTO accounts (balance, type, fk_user_id)
VALUES (
    $1,
    $2,
    $3
)
RETURNING balance, type, fk_user_id, created_at, updated_at, account_number
`

type OpenAccountParams struct {
	Balance  int64
	Type     AccountType
	FkUserID uuid.UUID
}

func (q *Queries) OpenAccount(ctx context.Context, arg OpenAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, openAccount, arg.Balance, arg.Type, arg.FkUserID)
	var i Account
	err := row.Scan(
		&i.Balance,
		&i.Type,
		&i.FkUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccountNumber,
	)
	return i, err
}

const openCheckingAccount = `-- name: OpenCheckingAccount :one
INSERT INTO checking_accounts (account_id, overdraft_limit, maintenance_fee)
VALUES (
    $1,
    $2,
    $3
)
RETURNING account_id, overdraft_limit, maintenance_fee
`

type OpenCheckingAccountParams struct {
	AccountID      uuid.UUID
	OverdraftLimit pgtype.Numeric
	MaintenanceFee int64
}

func (q *Queries) OpenCheckingAccount(ctx context.Context, arg OpenCheckingAccountParams) (CheckingAccount, error) {
	row := q.db.QueryRow(ctx, openCheckingAccount, arg.AccountID, arg.OverdraftLimit, arg.MaintenanceFee)
	var i CheckingAccount
	err := row.Scan(&i.AccountID, &i.OverdraftLimit, &i.MaintenanceFee)
	return i, err
}

const openSavingsAccount = `-- name: OpenSavingsAccount :one
INSERT INTO savings_accounts (account_id, interest_rate, min_balance, withdrawal_limit)
VALUES (
    $1,
    $2,
    $3,
    $4
)
RETURNING account_id, interest_rate, min_balance, withdrawal_limit
`

type OpenSavingsAccountParams struct {
	AccountID       uuid.UUID
	InterestRate    pgtype.Numeric
	MinBalance      int64
	WithdrawalLimit int64
}

func (q *Queries) OpenSavingsAccount(ctx context.Context, arg OpenSavingsAccountParams) (SavingsAccount, error) {
	row := q.db.QueryRow(ctx, openSavingsAccount,
		arg.AccountID,
		arg.InterestRate,
		arg.MinBalance,
		arg.WithdrawalLimit,
	)
	var i SavingsAccount
	err := row.Scan(
		&i.AccountID,
		&i.InterestRate,
		&i.MinBalance,
		&i.WithdrawalLimit,
	)
	return i, err
}

const updateBalanceDeposit = `-- name: UpdateBalanceDeposit :execrows
UPDATE accounts
SET
    balance = balance + $2,
    updated_at = CURRENT_TIMESTAMP
WHERE account_number = $1
`

type UpdateBalanceDepositParams struct {
	AccountNumber uuid.UUID
	Balance       int64
}

func (q *Queries) UpdateBalanceDeposit(ctx context.Context, arg UpdateBalanceDepositParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateBalanceDeposit, arg.AccountNumber, arg.Balance)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateBalanceWithdraw = `-- name: UpdateBalanceWithdraw :execrows
UPDATE accounts
SET
    balance = balance - $2,
    updated_at = CURRENT_TIMESTAMP
WHERE account_number = $1 AND balance >= $2
`

type UpdateBalanceWithdrawParams struct {
	AccountNumber uuid.UUID
	Balance       int64
}

func (q *Queries) UpdateBalanceWithdraw(ctx context.Context, arg UpdateBalanceWithdrawParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateBalanceWithdraw, arg.AccountNumber, arg.Balance)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
